
# CyclicBarrier

使用CyclicBarrier实现一个死锁，CyclicBarrier是一个汇集点（线程同步工具），等待所有线程都到了才会放行

```java
@Test
public void test() {
    ReentrantLock lock0 = new ReentrantLock();
    ReentrantLock lock1 = new ReentrantLock();
    CyclicBarrier barrier = new CyclicBarrier(2);
    new Thread(() -> {
        lock0.lock();
        try {
            barrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
        lock1.lock();
        System.out.println("线程1");
    }).start();
    new Thread(() -> {
        lock1.lock();
        try {
            barrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
        lock0.lock();
        System.out.println("线程2");
    }).start();

    ThreadUtil.sleep(10000L);
}
```

# CountDownLatch

使用CountDownLatch实现线程同步

```java
@Test
public void test() throws InterruptedException {

    CountDownLatch latch = new CountDownLatch(1);
    new Thread(() -> {
        ThreadUtil.sleep(1000);
        // do sth
        System.out.println("线程1任务结束");
        latch.countDown();
    }).start();
    // 等待所有latch结束
    latch.await();
    System.out.println("主线程");

    ThreadUtil.sleep(10000L);
}
```


# Semaphore

```java
@Test
public void semaphoreTest() throws InterruptedException {
    Semaphore semaphore = new Semaphore(1);
    
    new Thread(() -> {
        try {
            semaphore.acquire();
            System.out.println("子线程拿到信号量...");
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        semaphore.release();
        System.out.println("子线程释放信号量...");
    }).start();

    TimeUnit.SECONDS.sleep(1);
    semaphore.acquire();
    System.out.println("主线程拿到信号量...");
    TimeUnit.SECONDS.sleep(10);

}
```
