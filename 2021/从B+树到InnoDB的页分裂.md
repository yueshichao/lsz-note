> 参考：[07. MySQL 高级 - 索引 - 数据结构 - BTREE](https://b23.tv/JRHzHX)
> [InnoDB中的页合并与分裂](https://zhuanlan.zhihu.com/p/98818611)
> [设计 MySQL 数据表的时候一般都有一列为自增 ID，这样设计原因是什么，有什么好处？](https://www.zhihu.com/question/28703540/answer/494072901)
> [mysql中InnoDB引擎中页的概念](https://segmentfault.com/a/1190000008545713)

# InnoDB的聚簇索引
InnoDB一张表一个文件，主键只存在于数据行中，数据行间紧凑的存储在一起，我们叫做**聚簇索引**，聚簇索引并非MySQL常说的索引，而是一种存储方式  
这样做的好处是，主键没有副本，只存在于一处，你知道的，计算机的世界，为了不同地方的同一数据的一致，真的做了很多工作  
当你新建一个其他索引，叶子节点实际**存储是主键的值**，这样数据行移动，二级索引就不用费心维护了（如果叶子节点存储的是数据行位置，每次数据行动，所有索引都要改值）  



# B树
欲知B+树，先知B树  
B树，还有人叫B-树(B减树)，我个人认为这种读法不好，因为`B-树`翻译自`B-Tree`，实际没有`减`的意思，不能说有个B+树就叫B减树  
本质是一棵多叉树，以一棵m阶B树为例，性质如下：
- 每个节点至多有m个孩子
- 除根节点和叶子节点外，每个节点至少有m/2个孩子
- 所有叶节点在同一层(关于B树叶节点是哪一层有所争议，不过无妨)

## B树的插入分裂过程
假设m为5  
下面简单说说B树的插入，以及结点超过m个后的分裂过程  
例如现在插入：a,b,c,d,e,f
前5个没有问题，直接`(a b c d e)`  
插入第6个 - `f`，由于超过5个，结点分裂，中间值上移，且子节点分为两部分  
变为：
```
     (c)
    /   \
(a b)   (d e f)
```
如果父节点因为此次子值上移，导致数量超过m，则递归分裂即可

// TODO 代码实现


# B+树
MySQL文件放在硬盘上，InnoDB为了适应硬盘，**减少IO操作**，且为了方便**区间查询**，所以选择了B+树  
与B树其他性质差不多，但是**数据都放在叶子结点**上，且叶子结点本身有序，都持有下一结点的位置  

> B树与B+树本身也很适合做文件系统的逻辑结构
> 除此之外，还有**B*树**


# 页
硬盘属于块设备，寻址慢，读取慢，我们一般一次读写一大块的数据(4KB)  
MySQL抽象出页的概念，管理硬盘读写，一页16KB  
逻辑上你的数据行存储在B+树的一个个结点上，但结点最终要存储到硬盘上，也就是存储到页中  

逻辑上我们插入、删除的记录，都会根据主键大小，被InnoDB调整为有序(B+树)  
但在物理存储上，删除的记录，插入的新记录，都有可能会导致记录在磁盘上不连续  

# 页合并
举个例子，#1页上有5条记录，#2页上有5条记录  
删除#1上的3条记录，删除#2上的3条记录，#1和#2就可以合并为一页，放在一片连续的存储空间  
当然，InnoDB并不是靠数量判断是否可以页合并的，而是此页的空白容量**MERGE_THRESHOLD**  

> 我这里为了举例方便，认为每条记录大小相同  

# 页分裂
再举个例子，#1页上有5条记录，并且**此页已满**，#2也满了，#3也有几条记录    
此时我要插入一条新纪录，按B+树的规则，假设应插在#1，但#1已满，#2也没有剩余空间  
此时我们新建一页#4，重排页之间的逻辑关系：`#1 -> #4 -> #2 -> #3`
> 想起一句戏谑言论：计算机世界没什么什么不能通过抽象解决的，如果有，那就再抽象一层  
> 这里就是将连续的物理页，抽象出一层，变为链表页，逻辑上仍然连续，但物理上不连续了



# 总结
B+树是MySQL存储的**逻辑结构**，而页是存储的**物理结构**  
关于逻辑和物理结构，可以类比于操作系统的分段和分页，分段就是内存的逻辑分割，分页就是物理分割  
逻辑结构面向用户，便于操作；物理结构面向硬件，便于存取  

