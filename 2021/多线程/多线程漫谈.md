> 参考：[进程与线程](https://www.cnblogs.com/qianqiannian/p/7010909.html)
> [线程和进程的区别是什么？](https://www.zhihu.com/question/25532384/answer/411179772)
> [到底什么是用户态线程，内核态线程？](https://www.zhihu.com/question/328196975/answer/709257198)
> [linux用户级进程跟内核线程（进程）有什么差别呢？](https://www.zhihu.com/question/25367227/answer/149887860)
> [多线程编程的时候，使用无锁结构会不会比有锁结构更加快？](https://www.zhihu.com/question/53303879/answer/134936389)

# 多进程的起源
没错，虽然标题叫**多线程漫谈**，但我们从进程说起  
多进程的出现是为了充分利用CPU，书面一点，叫做**提升CPU吞吐率**  
原本计算机只能单任务，一个接一个的做  
但是实现多进程就多个任务交替执行  

- 多进程一定能提升任务执行效率吗(CPU任务吞吐率)？  
答案视情况而定，甚至可能降低任务执行效率  

- 什么情况下会提升任务提供效率？  
CPU很快，但并不是计算机很快，计算机运算，需要**输入，运算，输出**，其中输入，输出都是IO操作，无论是磁盘IO还是网络IO，都很慢(对于CPU运算而言)  
数据从**磁盘 -> 内存 -> 高速缓存 -> 寄存器**，如果A任务**CPU运算只要1s**，但**IO操作需要10s**，这时候CPU如果**忙等**就没有意义  
于是就把IO操作交给**DMA**去等待，自己执行其他进程去了  

> 举个例子，把CPU比作一个服务员，每个任务进程比作顾客，假设这些顾客脑子不太灵光，每次说自己需求都要先想一段时间  
> 之前只要顾客想要点菜，服务员就直接去了，现在不这样了，顾客想好了（甚至写好了），才会叫服务员去做事  

## 多进程切换的代价
之前提到IO操作，进程A发生阻塞，这时进程B执行，那么进程A结束阻塞，如何回来继续执行呢？  
其实是**保存上下文**，所谓的上下文，就是你进程中断的这一刻，寄存器、程序计数器等指令顺序执行所需的数据，等进程切换回来时，就**恢复现场(上下文)**  
而这个操作是**有代价的**  
想象一下，自己有很多事情要做时，频繁切换执行的任务是不是也挺累人的，毕竟要记住自己的工作进度  


## 进程的三种状态 - 就绪、运行、阻塞

> 也有五种状态的说法 - 新建，终止，运行，就绪，阻塞  

就绪 <-> 运行 -> 阻塞 -> (就绪)  

我们使用的操作系统大部分是**多任务多用户分时操作系统**，所以每个进程并不是独占CPU直到执行结束  
就绪时，等待分配到CPU时间片，进入运行态  
运行时，CPU时间片用完，进入就绪态; 或者进行了耗时的IO操作，进入阻塞态  
阻塞后，直到IO操作完成，进程重回就绪态，等待再次被调度  


# 多线程
## 进程与线程

教科书里说：**线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位**  
计算机起初是没有线程的，就像没有进程一样  
我理解为，为了更好的利用CPU(增大吞吐量)，于是在进程里面再抽象出线程  
线程就是**代码顺序执行的最小单位**，比起进程切换代价更小，而且一个进程分出多个线程来，我认为也更有利于软件开发  

> 个人认为，工程性的东西不要被教科书所桎梏，应在使用中逐渐理解  

## 用户级、内核级线程
再随便提一点线程的分类

1. 所谓内核级线程，就是指**操作系统提供的线程函数**创建的线程，以前版本的Linux没有，后来版本的Linux内核提供了  

2. 而用户级线程，就是编程语言提供的库函数，让你以为在操作多线程，实际**对于操作系统透明**(操作系统认为你是一整个进程)  

// TODO 各自特点、优劣
// TODO 用户级与内核级 -> 1:1 1:N M:N

## CAS - Compare And Swap
我们知道线程切换也是需要保存上下文的，那么就必然涉及**时间开销**  
而CAS操作就是为了减少线程切换  
CAS是计算机硬件提供的一种**原子操作**，顾名思义，就是**比较并交换**  

- 举个例子，将**内存地址0x01，原先数值2，修改为3**  
- 如果CAS修改时，原数值不是2，直接失败返回
- 如果原值是2，则修改成功

## CAS与线程切换
线程争取一个锁资源时，如果争取不到，有两种操作  

1. 线程阻塞，等待锁资源释放唤醒自己继续竞争  

2. 以CAS方式持续竞争  

线程切换需要保存上下文的开销，持续的CAS需要CPU忙等，哪个更好？  

看具体情况，如果你几次CAS就拿到锁了，那么CAS更好;  
如果锁竞争强度很大，造成CPU被CAS操作占满，那么CAS显然不合适  

> Java中并发控制工具大部分都是先CAS几次，接下来线程阻塞、入队、等待唤醒  
> 像synchronized关键字、ReentrantLock都是如此  

