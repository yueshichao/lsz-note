> 参考：  
> [分布式锁用Redis坚决不用Zookeeper？](https://cloud.tencent.com/developer/article/1476050)  
> [使用Redis实现分布式锁和ZK实现分布式锁有什么区别，分别有哪些场景?](https://www.zhihu.com/question/452803310/answer/1816290814)

# Redisson实现

## lock的lua实现

```lua
-- 第一次持锁时会进入此方法
if (redis.call('exists', KEYS[1]) == 0) then
    -- KEYS[1]不存在表示无锁，设置hash，key为锁名，value为1
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    -- 设置超时时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
-- 如果锁已经被持有
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    -- 有KEYS[1]表示有锁，此hash中key对应的参数为线程ID
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    -- 更新超时时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
-- 如果持锁未成功，返回锁剩余时间
return redis.call('pttl', KEYS[1]);

-- KEYS[1] 是锁名
-- ARGV[1] 是超时时间(ms)
-- ARGV[2] 是线程ID
-- 例如我的传参为 "1" "biz" "100000" "6775f92d-4650-404a-ba33-b13d91863330:1"
```

## unlock的lua实现

```lua
-- 验一下锁是不是自己的
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil; end
-- 锁值减1
local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1);
-- 如果值仍然大于0，说明重入过
if (counter > 0) then
    -- 刷新过期时间
    redis.call('pexpire', KEYS[1], ARGV[2]);
    return 0;
else
    -- 如果值小于等于0，删除此锁
    redis.call('del', KEYS[1]);
    -- 通知其他未抢到锁的客户端？
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1;
end
return nil;
-- KEYS[1] 是锁名
-- KEYS[2] 是发布事件名
-- ARGV[1] ？
-- ARGV[2] 是超时时间(ms)
-- ARGV[3] 是线程ID
-- 例如我的传参为 "2" "biz" "redisson_lock__channel:{biz}" "0" "100000" "6775f92d-4650-404a-ba33-b13d91863330:1"
```


