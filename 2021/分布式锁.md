> 参考：  
> [分布式锁用Redis坚决不用Zookeeper？](https://cloud.tencent.com/developer/article/1476050)  
> [使用Redis实现分布式锁和ZK实现分布式锁有什么区别，分别有哪些场景?](https://www.zhihu.com/question/452803310/answer/1816290814)

# Redisson实现

## 非公平锁

### lock的lua实现

```lua
-- 第一次持锁时会进入此方法
if (redis.call('exists', KEYS[1]) == 0) then
    -- KEYS[1]不存在表示无锁，设置hash，key为锁名，value为1
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    -- 设置超时时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
-- 如果锁已经被持有
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    -- 有KEYS[1]表示有锁，此hash中key对应的参数为线程ID
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    -- 更新超时时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
-- 如果持锁未成功，返回锁剩余时间
return redis.call('pttl', KEYS[1]);

-- KEYS[1] 是锁名
-- ARGV[1] 是超时时间(ms)
-- ARGV[2] 是线程ID
-- 例如我的传参为 "1" "biz" "100000" "6775f92d-4650-404a-ba33-b13d91863330:1"
```

### unlock的lua实现

```lua
-- 验一下锁是不是自己的
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil; end
-- 锁值减1
local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1);
-- 如果值仍然大于0，说明重入过
if (counter > 0) then
    -- 刷新过期时间
    redis.call('pexpire', KEYS[1], ARGV[2]);
    return 0;
else
    -- 如果值小于等于0，删除此锁
    redis.call('del', KEYS[1]);
    -- 通知其他未抢到锁的客户端？
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1;
end
return nil;
-- KEYS[1] 是锁名
-- KEYS[2] 是发布事件名
-- ARGV[1] ？
-- ARGV[2] 是超时时间(ms)
-- ARGV[3] 是线程ID
-- 例如我的传参为 "2" "biz" "redisson_lock__channel:{biz}" "0" "100000" "6775f92d-4650-404a-ba33-b13d91863330:1"
```

## 公平锁

### lock时的lua脚本
```lua
while true do
    local firstThreadId2 = redis.call('lindex', KEYS[2], 0);
    if firstThreadId2 == false then break end
    local timeout = tonumber(redis.call('zscore', KEYS[3], firstThreadId2));
    if timeout <= tonumber(ARGV[4]) then
        redis.call('zrem', KEYS[3], firstThreadId2);
        redis.call('lpop', KEYS[2]);
    else
        break
    end
end
-- 第一个拿到锁的
if (redis.call('exists', KEYS[1]) == 0) and
    ((redis.call('exists', KEYS[2]) == 0) or
        (redis.call('lindex', KEYS[2], 0) == ARGV[2])) then
    redis.call('lpop', KEYS[2]);
    redis.call('zrem', KEYS[3], ARGV[2]);
    local keys = redis.call('zrange', KEYS[3], 0, -1);
    for i = 1, #keys, 1 do
        redis.call('zincrby', KEYS[3], -tonumber(ARGV[3]), keys[i]);
    end
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
if redis.call('hexists', KEYS[1], ARGV[2]) == 1 then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end
local timeout = redis.call('zscore', KEYS[3], ARGV[2]);
if timeout ~= false then return timeout - tonumber(ARGV[3]) - tonumber(ARGV[4]); end
local lastThreadId = redis.call('lindex', KEYS[2], -1);
local ttl;
if lastThreadId ~= false and lastThreadId ~= ARGV[2] then
    ttl = tonumber(redis.call('zscore', KEYS[3], lastThreadId)) -
              tonumber(ARGV[4]);
else
    ttl = redis.call('pttl', KEYS[1]);
end
local timeout = ttl + tonumber(ARGV[3]) + tonumber(ARGV[4]);
if redis.call('zadd', KEYS[3], timeout, ARGV[2]) == 1 then
    redis.call('rpush', KEYS[2], ARGV[2]);
end
return ttl;


-- "3" "biz" "redisson_lock_queue:{biz}" "redisson_lock_timeout:{biz}" 
-- "100000" "9dd40db4-0b81-4c5e-a6a4-b31e5cc79ab2:1" "300000" "1619443667357"
```

